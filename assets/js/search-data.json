{
  
    
        "post0": {
            "title": "Gráficos de Violino - parte 1",
            "content": "Imports e prepara&#231;&#227;o dos dados . Os gráficos de violino violin plots ajudam a compreender a distribuição dos valores de um dataset. Neste post vamos utilizar a biblioteca seaborn para desenhar estes gráficos, e utilizaremos três distribuições sintéticas para explicar como se interpretam estes gráficos e mostrar algumas técnicas que ajudam a tornar as visualizações mais intuitivas. . Para começar precisamos de duas coisas: bibliotecas e dados! Iremos começar com um dataset com apeans três colunas, e com dados sintéticas fixos para perceber como são retratados estes casos básicos: . Igual - Nesta coluna todos os pontos têm o mesmo valor (0.5) | Extremos - Nesta coluna os valores estão nos extremos, metade em 0, metade em 1 | Uniforme - Nesta coluna os valores estão uniformemente distribuídos entre 0 e 1 | . Depois de dominarmos estes casos básicos, poderemos evoluir para datasets mais interessantes. . #collapse-hide import pandas as pd, numpy as np, matplotlib.pyplot as plt, seaborn as sns num_pontos=100 igual = 0.5*np.ones(num_pontos) extremos = np.sort((np.arange(num_pontos) % 2)) uniforme = np.arange(num_pontos) / num_pontos df = pd.DataFrame.from_dict({ &#39;Igual&#39;:igual, &#39;Extremos&#39;:extremos, &#39;Uniforme&#39;:uniforme}) df.plot(title=&quot;Valores de cada coluna&quot;); . . Gr&#225;ficos de Violino . Vamos então criar os nossos primeiros violin plots, um para cada coluna, senão são o que estavas à espera perfeito! Entao este post é perfeito para ti! . #collapse-hide fig, eixos = plt.subplots(1,3, figsize=(21,4)) sns.set(style=&quot;whitegrid&quot;) sns.violinplot(x = df.Igual, ax=eixos[0]); sns.violinplot(x = df.Uniforme, ax=eixos[1]); sns.violinplot(x = df.Extremos, ax=eixos[2]); . . Igual - valores todos iguais . Olhando para o gráfico abaixo é fácil de perceber que todos os pontos estão nos 0.5, exatamente como esperávamos. Perfeito! . #collapse-hide sns.violinplot(x=df.Igual); . . Uniforme - valores uniformemente distribu&#237;dos . O caso em que cada ponto tem um valor diferente, entre 0 e 1 é um pouco mais complicado de perceber, e neste caso ter uma grelha vai ajudar a explicar o que estamos a ver: . #collapse-hide sns.violinplot(x=df.Uniforme); . . Neste gráfico temos várias indicações da distribuíção dos valores: . o ponto branco no centro do gráfico representa a média | a linha preta fina mostra a distribuição dos valores, que estão entre 0 e 1 | a linha mais grossa mostra que 50% dos valores estão entre 0.25 e 0.75 | a azul é a estimativa da densidade de valores, ou seja aproximadamente quantos valores existem aí | . O gráfico de densidade (zona azul) não parece mostrar que todos os pontos aparecem o mesmo número de vezes (exatamente uma vez cada um). Poderias esperar um rectângulo entre 0 e 1 porque todos os pontos aparecem exatamente uma vez no dataset. A explicação é que a densidade está a ser calculada com base numa vizinhança de 0.25 para cada lado, e a curva está a ser alisada e cortada. Repara que: . para vizinhanças abaixo de -0.25 e acima de 1.25 não apanhamos quaisquer pontos | em 0 apanhamos apenas os pontos para a direita [0-0.25], pelo que temos 50% da densidade | em 1 apanhamos apenas os pontos para a esquerda [0.75-1], pelo que temos 50% da densidade | entre de 0.25 e 0.75 apanhamos todos os pontos de ambos os lados, pelo que o valor se mantém uniforme a 100% | . Extremos - metade em cada extremo . A explicação é semelhante ao exemplo anterior: . o ponto branco no centro do gráfico representa a média | a linha preta fina não aparece porque coincide com a grossa | a linha mais grossa mostra que 50% dos valores estão entre 0 e 1 (neste caso são até 100% dos valores) | a azul é a estimativa da densidade de valores, ou seja aproximadamente quantos valores existem aí | . Tal como anteriormente a zona azul aumenta até chegar aos extremos (onde estão localizados todos os pontos) e diminui com a distância aos extremos. . #collapse-hide sns.violinplot(x=df.Extremos); . . Melhorias . Um gr&#225;fico tr&#234;s violinos . A primeira melhoria que podemos fazer, e talvez a mais complicada, é juntar os vários violinos no mesmo gráfico. O seaborn suporta criar gráficos de violino agrupando os valores com base noutra coluna. Vamos utilizar a função melt do pandas, para criar um novo DataFrame com os dados das nossas 3 colunas originais na coluna valores, e a origem do valor na coluna coluna. . #collapse-hide novo_df = df.melt(value_vars=[&#39;Igual&#39;,&#39;Extremos&#39;,&#39;Uniforme&#39;], var_name=&#39;coluna&#39;, value_name=&#39;valores&#39;) novo_df.head() . . coluna valores . 0 Igual | 0.5 | . 1 Igual | 0.5 | . 2 Igual | 0.5 | . 3 Igual | 0.5 | . 4 Igual | 0.5 | . E aqui está o nosso violino agrupado por coluna: . #collapse-hide plt.rcParams[&#39;figure.figsize&#39;]=[16,5] sns.violinplot(x=&quot;coluna&quot;, y=&quot;valores&quot;, data=novo_df); . . Apenas os valores que existem . Caso tenhamos de partilhar a visualização com pessoas pouco técnicas, poderá ser complicado de explicar o conceito de densidade, e como aparecem valores negativos numa variável que só varia entre 0 e 1. Não há problema, há afinações simples que podemos fazer para tornar estes gráficos mais compreensíveis! . O parâmetro que limita os pontos que são utilizados para estimar a densidade chama-se cut e tem por defeito o valor 2. Podemos limitar a largura da janela para incluir apenas os valores que existem no dataset alterando este parâmetro cut para 0: . #collapse-hide sns.violinplot(x=&quot;coluna&quot;, y=&quot;valores&quot;, data=novo_df, cut=0); . . Alterar a estimativa de densidade . Bem melhor! Agora vamos tratar das estimativas de densidade estarem demasiado largas, e por isso darem uma ideia pouco precisa da real distribuição dos dados. . A largura que utilizada para estimar a densidade de pontos é controlada pelo parâmetro bw. . Ao utilizar um valor suficientemente baixo os pontos deixam de ser acumulados, e obtemos uma visualização muito mais precisa da forma dos dados: . #collapse-hide sns.violinplot(x=&quot;coluna&quot;, y=&quot;valores&quot;, data=novo_df, cut=0, bw=0.001); . . Efeito dos par&#226;metros . Abaixo a comparação dos valores dos parâmetros bw, e cut, ilustra bem a necessidade de escolher cuidadosamente os valores de bw e cut. Caso estes valores estejam desadequados poderemos ficar com uma ideia completamente errada da distribuição dos nossos dados! . #collapse-hide params = [ {&#39;l&#39;:0, &#39;bw&#39;:1, &#39;cor&#39;: &#39;rebeccapurple&#39;}, {&#39;l&#39;:1, &#39;bw&#39;:.1, &#39;cor&#39;: &#39;red&#39;}, {&#39;l&#39;:2, &#39;bw&#39;:.01, &#39;cor&#39;: &#39;gold&#39;}] def grafico(p, pos_col, cut): ax=axes[p[&#39;l&#39;], pos_col] sns.violinplot(x=&quot;coluna&quot;, y=&quot;valores&quot;, data=novo_df, cut=cut, bw=p[&#39;bw&#39;], ax=ax); ax.set_title(f&quot;bw={p[&#39;bw&#39;]}, cut={cut}&quot;) ax.set_xlabel(&quot;&quot;) fig, axes=plt.subplots(len(params),2, figsize=(16,len(params)*6)) for p in params: grafico(p, 0, 2) grafico(p, 1, 0) . . E por hoje já chega, obrigado pela companhia e até ao próximo post! .",
            "url": "https://zevarela.github.io/blog/fastpages/jupyter/visualiza%C3%A7%C3%A3o/gr%C3%A1ficos%20de%20violino/2020/04/05/violin-plots.html",
            "relUrl": "/fastpages/jupyter/visualiza%C3%A7%C3%A3o/gr%C3%A1ficos%20de%20violino/2020/04/05/violin-plots.html",
            "date": " • Apr 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Emoji no GitHub Pages",
            "content": "Suporte para emoji no GitHub Pages . Com fast_template . Quando criei este blog os emoji não apareciam corretamente no GitHub Pages, para que apareçam tive de acrescentar o jemoji à lista de plugins no ficheiro _config.yml. Obrigado ao Arnie97 pela dica. . Exemplo de um _config.yml para fast_template: . plugins: - jekyll-feed - jekyll-gist - jekyll-octicons - jekyll-github-metadata - jemoji . Com fastpages . Entretanto fiz o upgrade para fastpages, e foi necessário: . adicionar o jemoji ao _config.yml | adicionar o jemoji ao Gemfile | make build | . Listas de emoji . Utilizável no GitHub: https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md | Outras fontes: https://unicode.org/emoji/charts/full-emoji-list.html | .",
            "url": "https://zevarela.github.io/blog/fastpages/jupyter/2020/04/01/the-very-first-post.html",
            "relUrl": "/fastpages/jupyter/2020/04/01/the-very-first-post.html",
            "date": " • Apr 1, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Olá!",
          "content": "O autor deste blog sou eu, o José Araújo Varela, pai de duas crianças incríveis, marido da super mulher, e programador que adora aprender e resolver problemas. . Tenho a sorte de trabalhar no que mais me apaixona, numa empresa impecável, com uma equipa fantástica. Trabalho claro está como Lead Data Scientist na everis Portugal! . Neste momento as áreas que mais despertam o meu interesse são Deep Learning (especialmente object detection e treino eficiente), e visualização de dados. . Não passo muito tempo em redes sociais, podes tentar contactar-me no twitter ou linkedin, mas o mais fácil será provavelmente deixares um comentário aqui no blog. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://zevarela.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}